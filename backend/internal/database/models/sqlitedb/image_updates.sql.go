// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: image_updates.sql

package sqlitedb

import (
	"context"
	"database/sql"
	"strings"
	"time"
)

const countImageUpdates = `-- name: CountImageUpdates :one
SELECT COUNT(*)
FROM image_updates
`

func (q *Queries) CountImageUpdates(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countImageUpdates)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countImageUpdatesWithErrors = `-- name: CountImageUpdatesWithErrors :one
SELECT COUNT(*)
FROM image_updates
WHERE last_error IS NOT NULL
`

func (q *Queries) CountImageUpdatesWithErrors(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countImageUpdatesWithErrors)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countImageUpdatesWithUpdate = `-- name: CountImageUpdatesWithUpdate :one
SELECT COUNT(*)
FROM image_updates
WHERE has_update = true
`

func (q *Queries) CountImageUpdatesWithUpdate(ctx context.Context) (int64, error) {
	row := q.db.QueryRowContext(ctx, countImageUpdatesWithUpdate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countImageUpdatesWithUpdateType = `-- name: CountImageUpdatesWithUpdateType :one
SELECT COUNT(*)
FROM image_updates
WHERE has_update = true
	AND update_type = ?
`

func (q *Queries) CountImageUpdatesWithUpdateType(ctx context.Context, updateType sql.NullString) (int64, error) {
	row := q.db.QueryRowContext(ctx, countImageUpdatesWithUpdateType, updateType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteImageUpdatesByIDs = `-- name: DeleteImageUpdatesByIDs :execrows
DELETE FROM image_updates
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) DeleteImageUpdatesByIDs(ctx context.Context, ids []string) (int64, error) {
	query := deleteImageUpdatesByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	result, err := q.db.ExecContext(ctx, query, queryParams...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getImageUpdateByID = `-- name: GetImageUpdateByID :one
SELECT id,
			 repository,
			 tag,
			 has_update,
			 update_type,
			 current_version,
			 latest_version,
			 current_digest,
			 latest_digest,
			 check_time,
			 response_time_ms,
			 last_error,
			 auth_method,
			 auth_username,
			 auth_registry,
			 used_credential,
			 notification_sent,
			 created_at,
			 updated_at
FROM image_updates
WHERE id = ?
LIMIT 1
`

type GetImageUpdateByIDRow struct {
	ID               string         `json:"id"`
	Repository       string         `json:"repository"`
	Tag              string         `json:"tag"`
	HasUpdate        bool           `json:"has_update"`
	UpdateType       sql.NullString `json:"update_type"`
	CurrentVersion   string         `json:"current_version"`
	LatestVersion    sql.NullString `json:"latest_version"`
	CurrentDigest    sql.NullString `json:"current_digest"`
	LatestDigest     sql.NullString `json:"latest_digest"`
	CheckTime        time.Time      `json:"check_time"`
	ResponseTimeMs   int64          `json:"response_time_ms"`
	LastError        sql.NullString `json:"last_error"`
	AuthMethod       sql.NullString `json:"auth_method"`
	AuthUsername     sql.NullString `json:"auth_username"`
	AuthRegistry     sql.NullString `json:"auth_registry"`
	UsedCredential   sql.NullInt64  `json:"used_credential"`
	NotificationSent sql.NullInt64  `json:"notification_sent"`
	CreatedAt        time.Time      `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
}

func (q *Queries) GetImageUpdateByID(ctx context.Context, id string) (*GetImageUpdateByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getImageUpdateByID, id)
	var i GetImageUpdateByIDRow
	err := row.Scan(
		&i.ID,
		&i.Repository,
		&i.Tag,
		&i.HasUpdate,
		&i.UpdateType,
		&i.CurrentVersion,
		&i.LatestVersion,
		&i.CurrentDigest,
		&i.LatestDigest,
		&i.CheckTime,
		&i.ResponseTimeMs,
		&i.LastError,
		&i.AuthMethod,
		&i.AuthUsername,
		&i.AuthRegistry,
		&i.UsedCredential,
		&i.NotificationSent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listImageUpdates = `-- name: ListImageUpdates :many
SELECT id,
			 repository,
			 tag,
			 has_update,
			 update_type,
			 current_version,
			 latest_version,
			 current_digest,
			 latest_digest,
			 check_time,
			 response_time_ms,
			 last_error,
			 auth_method,
			 auth_username,
			 auth_registry,
			 used_credential,
			 notification_sent,
			 created_at,
			 updated_at
FROM image_updates
`

type ListImageUpdatesRow struct {
	ID               string         `json:"id"`
	Repository       string         `json:"repository"`
	Tag              string         `json:"tag"`
	HasUpdate        bool           `json:"has_update"`
	UpdateType       sql.NullString `json:"update_type"`
	CurrentVersion   string         `json:"current_version"`
	LatestVersion    sql.NullString `json:"latest_version"`
	CurrentDigest    sql.NullString `json:"current_digest"`
	LatestDigest     sql.NullString `json:"latest_digest"`
	CheckTime        time.Time      `json:"check_time"`
	ResponseTimeMs   int64          `json:"response_time_ms"`
	LastError        sql.NullString `json:"last_error"`
	AuthMethod       sql.NullString `json:"auth_method"`
	AuthUsername     sql.NullString `json:"auth_username"`
	AuthRegistry     sql.NullString `json:"auth_registry"`
	UsedCredential   sql.NullInt64  `json:"used_credential"`
	NotificationSent sql.NullInt64  `json:"notification_sent"`
	CreatedAt        time.Time      `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
}

func (q *Queries) ListImageUpdates(ctx context.Context) ([]*ListImageUpdatesRow, error) {
	rows, err := q.db.QueryContext(ctx, listImageUpdates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListImageUpdatesRow{}
	for rows.Next() {
		var i ListImageUpdatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Repository,
			&i.Tag,
			&i.HasUpdate,
			&i.UpdateType,
			&i.CurrentVersion,
			&i.LatestVersion,
			&i.CurrentDigest,
			&i.LatestDigest,
			&i.CheckTime,
			&i.ResponseTimeMs,
			&i.LastError,
			&i.AuthMethod,
			&i.AuthUsername,
			&i.AuthRegistry,
			&i.UsedCredential,
			&i.NotificationSent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImageUpdatesByIDs = `-- name: ListImageUpdatesByIDs :many
SELECT id,
			 repository,
			 tag,
			 has_update,
			 update_type,
			 current_version,
			 latest_version,
			 current_digest,
			 latest_digest,
			 check_time,
			 response_time_ms,
			 last_error,
			 auth_method,
			 auth_username,
			 auth_registry,
			 used_credential,
			 notification_sent,
			 created_at,
			 updated_at
FROM image_updates
WHERE id IN (/*SLICE:ids*/?)
`

type ListImageUpdatesByIDsRow struct {
	ID               string         `json:"id"`
	Repository       string         `json:"repository"`
	Tag              string         `json:"tag"`
	HasUpdate        bool           `json:"has_update"`
	UpdateType       sql.NullString `json:"update_type"`
	CurrentVersion   string         `json:"current_version"`
	LatestVersion    sql.NullString `json:"latest_version"`
	CurrentDigest    sql.NullString `json:"current_digest"`
	LatestDigest     sql.NullString `json:"latest_digest"`
	CheckTime        time.Time      `json:"check_time"`
	ResponseTimeMs   int64          `json:"response_time_ms"`
	LastError        sql.NullString `json:"last_error"`
	AuthMethod       sql.NullString `json:"auth_method"`
	AuthUsername     sql.NullString `json:"auth_username"`
	AuthRegistry     sql.NullString `json:"auth_registry"`
	UsedCredential   sql.NullInt64  `json:"used_credential"`
	NotificationSent sql.NullInt64  `json:"notification_sent"`
	CreatedAt        time.Time      `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
}

func (q *Queries) ListImageUpdatesByIDs(ctx context.Context, ids []string) ([]*ListImageUpdatesByIDsRow, error) {
	query := listImageUpdatesByIDs
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListImageUpdatesByIDsRow{}
	for rows.Next() {
		var i ListImageUpdatesByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Repository,
			&i.Tag,
			&i.HasUpdate,
			&i.UpdateType,
			&i.CurrentVersion,
			&i.LatestVersion,
			&i.CurrentDigest,
			&i.LatestDigest,
			&i.CheckTime,
			&i.ResponseTimeMs,
			&i.LastError,
			&i.AuthMethod,
			&i.AuthUsername,
			&i.AuthRegistry,
			&i.UsedCredential,
			&i.NotificationSent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImageUpdatesWithUpdate = `-- name: ListImageUpdatesWithUpdate :many
SELECT id,
			 repository,
			 tag,
			 has_update,
			 update_type,
			 current_version,
			 latest_version,
			 current_digest,
			 latest_digest,
			 check_time,
			 response_time_ms,
			 last_error,
			 auth_method,
			 auth_username,
			 auth_registry,
			 used_credential,
			 notification_sent,
			 created_at,
			 updated_at
FROM image_updates
WHERE has_update = true
`

type ListImageUpdatesWithUpdateRow struct {
	ID               string         `json:"id"`
	Repository       string         `json:"repository"`
	Tag              string         `json:"tag"`
	HasUpdate        bool           `json:"has_update"`
	UpdateType       sql.NullString `json:"update_type"`
	CurrentVersion   string         `json:"current_version"`
	LatestVersion    sql.NullString `json:"latest_version"`
	CurrentDigest    sql.NullString `json:"current_digest"`
	LatestDigest     sql.NullString `json:"latest_digest"`
	CheckTime        time.Time      `json:"check_time"`
	ResponseTimeMs   int64          `json:"response_time_ms"`
	LastError        sql.NullString `json:"last_error"`
	AuthMethod       sql.NullString `json:"auth_method"`
	AuthUsername     sql.NullString `json:"auth_username"`
	AuthRegistry     sql.NullString `json:"auth_registry"`
	UsedCredential   sql.NullInt64  `json:"used_credential"`
	NotificationSent sql.NullInt64  `json:"notification_sent"`
	CreatedAt        time.Time      `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
}

func (q *Queries) ListImageUpdatesWithUpdate(ctx context.Context) ([]*ListImageUpdatesWithUpdateRow, error) {
	rows, err := q.db.QueryContext(ctx, listImageUpdatesWithUpdate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListImageUpdatesWithUpdateRow{}
	for rows.Next() {
		var i ListImageUpdatesWithUpdateRow
		if err := rows.Scan(
			&i.ID,
			&i.Repository,
			&i.Tag,
			&i.HasUpdate,
			&i.UpdateType,
			&i.CurrentVersion,
			&i.LatestVersion,
			&i.CurrentDigest,
			&i.LatestDigest,
			&i.CheckTime,
			&i.ResponseTimeMs,
			&i.LastError,
			&i.AuthMethod,
			&i.AuthUsername,
			&i.AuthRegistry,
			&i.UsedCredential,
			&i.NotificationSent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnnotifiedImageUpdates = `-- name: ListUnnotifiedImageUpdates :many
SELECT id,
			 repository,
			 tag,
			 has_update,
			 update_type,
			 current_version,
			 latest_version,
			 current_digest,
			 latest_digest,
			 check_time,
			 response_time_ms,
			 last_error,
			 auth_method,
			 auth_username,
			 auth_registry,
			 used_credential,
			 notification_sent,
			 created_at,
			 updated_at
FROM image_updates
WHERE has_update = true
	AND notification_sent = false
`

type ListUnnotifiedImageUpdatesRow struct {
	ID               string         `json:"id"`
	Repository       string         `json:"repository"`
	Tag              string         `json:"tag"`
	HasUpdate        bool           `json:"has_update"`
	UpdateType       sql.NullString `json:"update_type"`
	CurrentVersion   string         `json:"current_version"`
	LatestVersion    sql.NullString `json:"latest_version"`
	CurrentDigest    sql.NullString `json:"current_digest"`
	LatestDigest     sql.NullString `json:"latest_digest"`
	CheckTime        time.Time      `json:"check_time"`
	ResponseTimeMs   int64          `json:"response_time_ms"`
	LastError        sql.NullString `json:"last_error"`
	AuthMethod       sql.NullString `json:"auth_method"`
	AuthUsername     sql.NullString `json:"auth_username"`
	AuthRegistry     sql.NullString `json:"auth_registry"`
	UsedCredential   sql.NullInt64  `json:"used_credential"`
	NotificationSent sql.NullInt64  `json:"notification_sent"`
	CreatedAt        time.Time      `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
}

func (q *Queries) ListUnnotifiedImageUpdates(ctx context.Context) ([]*ListUnnotifiedImageUpdatesRow, error) {
	rows, err := q.db.QueryContext(ctx, listUnnotifiedImageUpdates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListUnnotifiedImageUpdatesRow{}
	for rows.Next() {
		var i ListUnnotifiedImageUpdatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Repository,
			&i.Tag,
			&i.HasUpdate,
			&i.UpdateType,
			&i.CurrentVersion,
			&i.LatestVersion,
			&i.CurrentDigest,
			&i.LatestDigest,
			&i.CheckTime,
			&i.ResponseTimeMs,
			&i.LastError,
			&i.AuthMethod,
			&i.AuthUsername,
			&i.AuthRegistry,
			&i.UsedCredential,
			&i.NotificationSent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markImageUpdatesNotified = `-- name: MarkImageUpdatesNotified :exec
UPDATE image_updates
SET notification_sent = true,
		updated_at = CURRENT_TIMESTAMP
WHERE id IN (/*SLICE:ids*/?)
`

func (q *Queries) MarkImageUpdatesNotified(ctx context.Context, ids []string) error {
	query := markImageUpdatesNotified
	var queryParams []interface{}
	if len(ids) > 0 {
		for _, v := range ids {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:ids*/?", strings.Repeat(",?", len(ids))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:ids*/?", "NULL", 1)
	}
	_, err := q.db.ExecContext(ctx, query, queryParams...)
	return err
}

const saveImageUpdate = `-- name: SaveImageUpdate :one
INSERT INTO image_updates (
		id,
		repository,
		tag,
		has_update,
		update_type,
		current_version,
		latest_version,
		current_digest,
		latest_digest,
		check_time,
		response_time_ms,
		last_error,
		auth_method,
		auth_username,
		auth_registry,
		used_credential,
		notification_sent,
		created_at,
		updated_at
)
VALUES (
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		?,
		CURRENT_TIMESTAMP,
		CURRENT_TIMESTAMP
)
ON CONFLICT(id) DO UPDATE SET
		repository = excluded.repository,
		tag = excluded.tag,
		has_update = excluded.has_update,
		update_type = excluded.update_type,
		current_version = excluded.current_version,
		latest_version = excluded.latest_version,
		current_digest = excluded.current_digest,
		latest_digest = excluded.latest_digest,
		check_time = excluded.check_time,
		response_time_ms = excluded.response_time_ms,
		last_error = excluded.last_error,
		auth_method = excluded.auth_method,
		auth_username = excluded.auth_username,
		auth_registry = excluded.auth_registry,
		used_credential = excluded.used_credential,
		notification_sent = excluded.notification_sent,
		updated_at = CURRENT_TIMESTAMP
RETURNING id,
					repository,
					tag,
					has_update,
					update_type,
					current_version,
					latest_version,
					current_digest,
					latest_digest,
					check_time,
					response_time_ms,
					last_error,
					auth_method,
					auth_username,
					auth_registry,
					used_credential,
					notification_sent,
					created_at,
					updated_at
`

type SaveImageUpdateParams struct {
	ID               string         `json:"id"`
	Repository       string         `json:"repository"`
	Tag              string         `json:"tag"`
	HasUpdate        bool           `json:"has_update"`
	UpdateType       sql.NullString `json:"update_type"`
	CurrentVersion   string         `json:"current_version"`
	LatestVersion    sql.NullString `json:"latest_version"`
	CurrentDigest    sql.NullString `json:"current_digest"`
	LatestDigest     sql.NullString `json:"latest_digest"`
	CheckTime        time.Time      `json:"check_time"`
	ResponseTimeMs   int64          `json:"response_time_ms"`
	LastError        sql.NullString `json:"last_error"`
	AuthMethod       sql.NullString `json:"auth_method"`
	AuthUsername     sql.NullString `json:"auth_username"`
	AuthRegistry     sql.NullString `json:"auth_registry"`
	UsedCredential   sql.NullInt64  `json:"used_credential"`
	NotificationSent sql.NullInt64  `json:"notification_sent"`
}

type SaveImageUpdateRow struct {
	ID               string         `json:"id"`
	Repository       string         `json:"repository"`
	Tag              string         `json:"tag"`
	HasUpdate        bool           `json:"has_update"`
	UpdateType       sql.NullString `json:"update_type"`
	CurrentVersion   string         `json:"current_version"`
	LatestVersion    sql.NullString `json:"latest_version"`
	CurrentDigest    sql.NullString `json:"current_digest"`
	LatestDigest     sql.NullString `json:"latest_digest"`
	CheckTime        time.Time      `json:"check_time"`
	ResponseTimeMs   int64          `json:"response_time_ms"`
	LastError        sql.NullString `json:"last_error"`
	AuthMethod       sql.NullString `json:"auth_method"`
	AuthUsername     sql.NullString `json:"auth_username"`
	AuthRegistry     sql.NullString `json:"auth_registry"`
	UsedCredential   sql.NullInt64  `json:"used_credential"`
	NotificationSent sql.NullInt64  `json:"notification_sent"`
	CreatedAt        time.Time      `json:"created_at"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
}

func (q *Queries) SaveImageUpdate(ctx context.Context, arg SaveImageUpdateParams) (*SaveImageUpdateRow, error) {
	row := q.db.QueryRowContext(ctx, saveImageUpdate,
		arg.ID,
		arg.Repository,
		arg.Tag,
		arg.HasUpdate,
		arg.UpdateType,
		arg.CurrentVersion,
		arg.LatestVersion,
		arg.CurrentDigest,
		arg.LatestDigest,
		arg.CheckTime,
		arg.ResponseTimeMs,
		arg.LastError,
		arg.AuthMethod,
		arg.AuthUsername,
		arg.AuthRegistry,
		arg.UsedCredential,
		arg.NotificationSent,
	)
	var i SaveImageUpdateRow
	err := row.Scan(
		&i.ID,
		&i.Repository,
		&i.Tag,
		&i.HasUpdate,
		&i.UpdateType,
		&i.CurrentVersion,
		&i.LatestVersion,
		&i.CurrentDigest,
		&i.LatestDigest,
		&i.CheckTime,
		&i.ResponseTimeMs,
		&i.LastError,
		&i.AuthMethod,
		&i.AuthUsername,
		&i.AuthRegistry,
		&i.UsedCredential,
		&i.NotificationSent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateImageUpdateHasUpdateByRepositoryTag = `-- name: UpdateImageUpdateHasUpdateByRepositoryTag :exec
UPDATE image_updates
SET has_update = ?,
		updated_at = CURRENT_TIMESTAMP
WHERE repository = ?
	AND tag = ?
`

type UpdateImageUpdateHasUpdateByRepositoryTagParams struct {
	HasUpdate  bool   `json:"has_update"`
	Repository string `json:"repository"`
	Tag        string `json:"tag"`
}

func (q *Queries) UpdateImageUpdateHasUpdateByRepositoryTag(ctx context.Context, arg UpdateImageUpdateHasUpdateByRepositoryTagParams) error {
	_, err := q.db.ExecContext(ctx, updateImageUpdateHasUpdateByRepositoryTag, arg.HasUpdate, arg.Repository, arg.Tag)
	return err
}
