// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: environments.sql

package sqlitedb

import (
	"context"
	"database/sql"
	"time"
)

const createEnvironment = `-- name: CreateEnvironment :one
INSERT INTO environments (
    id,
    name,
    api_url,
    status,
    enabled,
    is_edge,
    last_seen,
    access_token,
    api_key_id,
    created_at,
    updated_at
)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
RETURNING id, api_url, status, enabled, last_seen, created_at, updated_at, access_token, name, api_key_id, is_edge
`

type CreateEnvironmentParams struct {
	ID          string         `json:"id"`
	Name        sql.NullString `json:"name"`
	ApiUrl      string         `json:"api_url"`
	Status      string         `json:"status"`
	Enabled     bool           `json:"enabled"`
	IsEdge      int64          `json:"is_edge"`
	LastSeen    sql.NullTime   `json:"last_seen"`
	AccessToken sql.NullString `json:"access_token"`
	ApiKeyID    sql.NullString `json:"api_key_id"`
	CreatedAt   time.Time      `json:"created_at"`
	UpdatedAt   sql.NullTime   `json:"updated_at"`
}

func (q *Queries) CreateEnvironment(ctx context.Context, arg CreateEnvironmentParams) (*Environment, error) {
	row := q.db.QueryRowContext(ctx, createEnvironment,
		arg.ID,
		arg.Name,
		arg.ApiUrl,
		arg.Status,
		arg.Enabled,
		arg.IsEdge,
		arg.LastSeen,
		arg.AccessToken,
		arg.ApiKeyID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.ApiUrl,
		&i.Status,
		&i.Enabled,
		&i.LastSeen,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.Name,
		&i.ApiKeyID,
		&i.IsEdge,
	)
	return &i, err
}

const deleteEnvironmentByID = `-- name: DeleteEnvironmentByID :execrows
DELETE FROM environments
WHERE id = ?
`

func (q *Queries) DeleteEnvironmentByID(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteEnvironmentByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const findEnvironmentIDByApiKeyHash = `-- name: FindEnvironmentIDByApiKeyHash :one
SELECT environments.id
FROM environments
INNER JOIN api_keys ON api_keys.id = environments.api_key_id
WHERE api_keys.key_hash = ?
LIMIT 1
`

func (q *Queries) FindEnvironmentIDByApiKeyHash(ctx context.Context, keyHash string) (string, error) {
	row := q.db.QueryRowContext(ctx, findEnvironmentIDByApiKeyHash, keyHash)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getEnvironmentByID = `-- name: GetEnvironmentByID :one
SELECT id, api_url, status, enabled, last_seen, created_at, updated_at, access_token, name, api_key_id, is_edge
FROM environments
WHERE id = ?
LIMIT 1
`

func (q *Queries) GetEnvironmentByID(ctx context.Context, id string) (*Environment, error) {
	row := q.db.QueryRowContext(ctx, getEnvironmentByID, id)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.ApiUrl,
		&i.Status,
		&i.Enabled,
		&i.LastSeen,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.Name,
		&i.ApiKeyID,
		&i.IsEdge,
	)
	return &i, err
}

const listEnvironments = `-- name: ListEnvironments :many
SELECT id, api_url, status, enabled, last_seen, created_at, updated_at, access_token, name, api_key_id, is_edge
FROM environments
`

func (q *Queries) ListEnvironments(ctx context.Context) ([]*Environment, error) {
	rows, err := q.db.QueryContext(ctx, listEnvironments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Environment{}
	for rows.Next() {
		var i Environment
		if err := rows.Scan(
			&i.ID,
			&i.ApiUrl,
			&i.Status,
			&i.Enabled,
			&i.LastSeen,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessToken,
			&i.Name,
			&i.ApiKeyID,
			&i.IsEdge,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRemoteEnvironments = `-- name: ListRemoteEnvironments :many
SELECT id, api_url, status, enabled, last_seen, created_at, updated_at, access_token, name, api_key_id, is_edge
FROM environments
WHERE id != '0' AND enabled = true
`

func (q *Queries) ListRemoteEnvironments(ctx context.Context) ([]*Environment, error) {
	rows, err := q.db.QueryContext(ctx, listRemoteEnvironments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Environment{}
	for rows.Next() {
		var i Environment
		if err := rows.Scan(
			&i.ID,
			&i.ApiUrl,
			&i.Status,
			&i.Enabled,
			&i.LastSeen,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessToken,
			&i.Name,
			&i.ApiKeyID,
			&i.IsEdge,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const patchEnvironment = `-- name: PatchEnvironment :one
UPDATE environments
SET
    name = COALESCE(?1, name),
    api_url = COALESCE(?2, api_url),
    status = COALESCE(?3, status),
    enabled = COALESCE(?4, enabled),
    is_edge = COALESCE(?5, is_edge),
    last_seen = CASE WHEN ?6 = 1 THEN NULL ELSE COALESCE(?7, last_seen) END,
    access_token = CASE WHEN ?8 = 1 THEN NULL ELSE COALESCE(?9, access_token) END,
    api_key_id = CASE WHEN ?10 = 1 THEN NULL ELSE COALESCE(?11, api_key_id) END,
    updated_at = COALESCE(?12, updated_at)
WHERE id = ?13
RETURNING id, api_url, status, enabled, last_seen, created_at, updated_at, access_token, name, api_key_id, is_edge
`

type PatchEnvironmentParams struct {
	Name             sql.NullString `json:"name"`
	ApiUrl           sql.NullString `json:"api_url"`
	Status           sql.NullString `json:"status"`
	Enabled          sql.NullBool   `json:"enabled"`
	IsEdge           sql.NullInt64  `json:"is_edge"`
	ClearLastSeen    interface{}    `json:"clear_last_seen"`
	LastSeen         sql.NullTime   `json:"last_seen"`
	ClearAccessToken interface{}    `json:"clear_access_token"`
	AccessToken      sql.NullString `json:"access_token"`
	ClearApiKeyID    interface{}    `json:"clear_api_key_id"`
	ApiKeyID         sql.NullString `json:"api_key_id"`
	UpdatedAt        sql.NullTime   `json:"updated_at"`
	ID               string         `json:"id"`
}

func (q *Queries) PatchEnvironment(ctx context.Context, arg PatchEnvironmentParams) (*Environment, error) {
	row := q.db.QueryRowContext(ctx, patchEnvironment,
		arg.Name,
		arg.ApiUrl,
		arg.Status,
		arg.Enabled,
		arg.IsEdge,
		arg.ClearLastSeen,
		arg.LastSeen,
		arg.ClearAccessToken,
		arg.AccessToken,
		arg.ClearApiKeyID,
		arg.ApiKeyID,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.ApiUrl,
		&i.Status,
		&i.Enabled,
		&i.LastSeen,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.Name,
		&i.ApiKeyID,
		&i.IsEdge,
	)
	return &i, err
}

const touchEnvironmentHeartbeatIfStale = `-- name: TouchEnvironmentHeartbeatIfStale :execrows
UPDATE environments
SET last_seen = ?,
    status = ?,
    updated_at = ?
WHERE id = ?
  AND (last_seen IS NULL OR last_seen < ?)
`

type TouchEnvironmentHeartbeatIfStaleParams struct {
	LastSeen   sql.NullTime `json:"last_seen"`
	Status     string       `json:"status"`
	UpdatedAt  sql.NullTime `json:"updated_at"`
	ID         string       `json:"id"`
	LastSeen_2 sql.NullTime `json:"last_seen_2"`
}

func (q *Queries) TouchEnvironmentHeartbeatIfStale(ctx context.Context, arg TouchEnvironmentHeartbeatIfStaleParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, touchEnvironmentHeartbeatIfStale,
		arg.LastSeen,
		arg.Status,
		arg.UpdatedAt,
		arg.ID,
		arg.LastSeen_2,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
