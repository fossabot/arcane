// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: environments.sql

package pgdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createEnvironment = `-- name: CreateEnvironment :one
INSERT INTO environments (
    id,
    name,
    api_url,
    status,
    enabled,
    is_edge,
    last_seen,
    access_token,
    api_key_id,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, api_url, status, enabled, last_seen, created_at, updated_at, access_token, name, api_key_id, is_edge
`

type CreateEnvironmentParams struct {
	ID          string             `json:"id"`
	Name        pgtype.Text        `json:"name"`
	ApiUrl      string             `json:"api_url"`
	Status      string             `json:"status"`
	Enabled     bool               `json:"enabled"`
	IsEdge      bool               `json:"is_edge"`
	LastSeen    pgtype.Timestamptz `json:"last_seen"`
	AccessToken pgtype.Text        `json:"access_token"`
	ApiKeyID    pgtype.Text        `json:"api_key_id"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateEnvironment(ctx context.Context, arg CreateEnvironmentParams) (*Environment, error) {
	row := q.db.QueryRow(ctx, createEnvironment,
		arg.ID,
		arg.Name,
		arg.ApiUrl,
		arg.Status,
		arg.Enabled,
		arg.IsEdge,
		arg.LastSeen,
		arg.AccessToken,
		arg.ApiKeyID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.ApiUrl,
		&i.Status,
		&i.Enabled,
		&i.LastSeen,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.Name,
		&i.ApiKeyID,
		&i.IsEdge,
	)
	return &i, err
}

const deleteEnvironmentByID = `-- name: DeleteEnvironmentByID :execrows
DELETE FROM environments
WHERE id = $1
`

func (q *Queries) DeleteEnvironmentByID(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteEnvironmentByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findEnvironmentIDByApiKeyHash = `-- name: FindEnvironmentIDByApiKeyHash :one
SELECT environments.id
FROM environments
INNER JOIN api_keys ON api_keys.id = environments.api_key_id
WHERE api_keys.key_hash = $1
LIMIT 1
`

func (q *Queries) FindEnvironmentIDByApiKeyHash(ctx context.Context, keyHash string) (string, error) {
	row := q.db.QueryRow(ctx, findEnvironmentIDByApiKeyHash, keyHash)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getEnvironmentByID = `-- name: GetEnvironmentByID :one
SELECT id, api_url, status, enabled, last_seen, created_at, updated_at, access_token, name, api_key_id, is_edge
FROM environments
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetEnvironmentByID(ctx context.Context, id string) (*Environment, error) {
	row := q.db.QueryRow(ctx, getEnvironmentByID, id)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.ApiUrl,
		&i.Status,
		&i.Enabled,
		&i.LastSeen,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.Name,
		&i.ApiKeyID,
		&i.IsEdge,
	)
	return &i, err
}

const listEnvironments = `-- name: ListEnvironments :many
SELECT id, api_url, status, enabled, last_seen, created_at, updated_at, access_token, name, api_key_id, is_edge
FROM environments
`

func (q *Queries) ListEnvironments(ctx context.Context) ([]*Environment, error) {
	rows, err := q.db.Query(ctx, listEnvironments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Environment{}
	for rows.Next() {
		var i Environment
		if err := rows.Scan(
			&i.ID,
			&i.ApiUrl,
			&i.Status,
			&i.Enabled,
			&i.LastSeen,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessToken,
			&i.Name,
			&i.ApiKeyID,
			&i.IsEdge,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRemoteEnvironments = `-- name: ListRemoteEnvironments :many
SELECT id, api_url, status, enabled, last_seen, created_at, updated_at, access_token, name, api_key_id, is_edge
FROM environments
WHERE id != '0' AND enabled = true
`

func (q *Queries) ListRemoteEnvironments(ctx context.Context) ([]*Environment, error) {
	rows, err := q.db.Query(ctx, listRemoteEnvironments)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Environment{}
	for rows.Next() {
		var i Environment
		if err := rows.Scan(
			&i.ID,
			&i.ApiUrl,
			&i.Status,
			&i.Enabled,
			&i.LastSeen,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AccessToken,
			&i.Name,
			&i.ApiKeyID,
			&i.IsEdge,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const patchEnvironment = `-- name: PatchEnvironment :one
UPDATE environments
SET
    name = COALESCE($1, name),
    api_url = COALESCE($2, api_url),
    status = COALESCE($3, status),
    enabled = COALESCE($4, enabled),
    is_edge = COALESCE($5, is_edge),
    last_seen = CASE WHEN $6::boolean THEN NULL ELSE COALESCE($7, last_seen) END,
    access_token = CASE WHEN $8::boolean THEN NULL ELSE COALESCE($9, access_token) END,
    api_key_id = CASE WHEN $10::boolean THEN NULL ELSE COALESCE($11, api_key_id) END,
    updated_at = COALESCE($12, updated_at)
WHERE id = $13
RETURNING id, api_url, status, enabled, last_seen, created_at, updated_at, access_token, name, api_key_id, is_edge
`

type PatchEnvironmentParams struct {
	Name             pgtype.Text        `json:"name"`
	ApiUrl           pgtype.Text        `json:"api_url"`
	Status           pgtype.Text        `json:"status"`
	Enabled          pgtype.Bool        `json:"enabled"`
	IsEdge           pgtype.Bool        `json:"is_edge"`
	ClearLastSeen    bool               `json:"clear_last_seen"`
	LastSeen         pgtype.Timestamptz `json:"last_seen"`
	ClearAccessToken bool               `json:"clear_access_token"`
	AccessToken      pgtype.Text        `json:"access_token"`
	ClearApiKeyID    bool               `json:"clear_api_key_id"`
	ApiKeyID         pgtype.Text        `json:"api_key_id"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
	ID               string             `json:"id"`
}

func (q *Queries) PatchEnvironment(ctx context.Context, arg PatchEnvironmentParams) (*Environment, error) {
	row := q.db.QueryRow(ctx, patchEnvironment,
		arg.Name,
		arg.ApiUrl,
		arg.Status,
		arg.Enabled,
		arg.IsEdge,
		arg.ClearLastSeen,
		arg.LastSeen,
		arg.ClearAccessToken,
		arg.AccessToken,
		arg.ClearApiKeyID,
		arg.ApiKeyID,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Environment
	err := row.Scan(
		&i.ID,
		&i.ApiUrl,
		&i.Status,
		&i.Enabled,
		&i.LastSeen,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AccessToken,
		&i.Name,
		&i.ApiKeyID,
		&i.IsEdge,
	)
	return &i, err
}

const touchEnvironmentHeartbeatIfStale = `-- name: TouchEnvironmentHeartbeatIfStale :execrows
UPDATE environments
SET last_seen = $2,
    status = $3,
    updated_at = $2
WHERE id = $1
  AND (last_seen IS NULL OR last_seen < $4)
`

type TouchEnvironmentHeartbeatIfStaleParams struct {
	ID         string             `json:"id"`
	LastSeen   pgtype.Timestamptz `json:"last_seen"`
	Status     string             `json:"status"`
	LastSeen_2 pgtype.Timestamptz `json:"last_seen_2"`
}

func (q *Queries) TouchEnvironmentHeartbeatIfStale(ctx context.Context, arg TouchEnvironmentHeartbeatIfStaleParams) (int64, error) {
	result, err := q.db.Exec(ctx, touchEnvironmentHeartbeatIfStale,
		arg.ID,
		arg.LastSeen,
		arg.Status,
		arg.LastSeen_2,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}
