// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: git_repositories.sql

package pgdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countGitOpsSyncsByRepositoryID = `-- name: CountGitOpsSyncsByRepositoryID :one
SELECT COUNT(*)::bigint
FROM gitops_syncs
WHERE repository_id = $1
`

func (q *Queries) CountGitOpsSyncsByRepositoryID(ctx context.Context, repositoryID string) (int64, error) {
	row := q.db.QueryRow(ctx, countGitOpsSyncsByRepositoryID, repositoryID)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const createGitRepository = `-- name: CreateGitRepository :one
INSERT INTO git_repositories (
    id,
    name,
    url,
    auth_type,
    username,
    token,
    ssh_key,
    description,
    enabled,
    ssh_host_key_verification,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, name, url, auth_type, username, token, ssh_key, description, enabled, created_at, updated_at, ssh_host_key_verification
`

type CreateGitRepositoryParams struct {
	ID                     string             `json:"id"`
	Name                   string             `json:"name"`
	Url                    string             `json:"url"`
	AuthType               string             `json:"auth_type"`
	Username               pgtype.Text        `json:"username"`
	Token                  pgtype.Text        `json:"token"`
	SshKey                 pgtype.Text        `json:"ssh_key"`
	Description            pgtype.Text        `json:"description"`
	Enabled                bool               `json:"enabled"`
	SshHostKeyVerification string             `json:"ssh_host_key_verification"`
	CreatedAt              pgtype.Timestamptz `json:"created_at"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateGitRepository(ctx context.Context, arg CreateGitRepositoryParams) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, createGitRepository,
		arg.ID,
		arg.Name,
		arg.Url,
		arg.AuthType,
		arg.Username,
		arg.Token,
		arg.SshKey,
		arg.Description,
		arg.Enabled,
		arg.SshHostKeyVerification,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.AuthType,
		&i.Username,
		&i.Token,
		&i.SshKey,
		&i.Description,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SshHostKeyVerification,
	)
	return &i, err
}

const deleteGitRepositoryByID = `-- name: DeleteGitRepositoryByID :execrows
DELETE FROM git_repositories
WHERE id = $1
`

func (q *Queries) DeleteGitRepositoryByID(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteGitRepositoryByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getGitRepositoryByID = `-- name: GetGitRepositoryByID :one
SELECT id, name, url, auth_type, username, token, ssh_key, description, enabled, created_at, updated_at, ssh_host_key_verification
FROM git_repositories
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetGitRepositoryByID(ctx context.Context, id string) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, getGitRepositoryByID, id)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.AuthType,
		&i.Username,
		&i.Token,
		&i.SshKey,
		&i.Description,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SshHostKeyVerification,
	)
	return &i, err
}

const getGitRepositoryByName = `-- name: GetGitRepositoryByName :one
SELECT id, name, url, auth_type, username, token, ssh_key, description, enabled, created_at, updated_at, ssh_host_key_verification
FROM git_repositories
WHERE name = $1
LIMIT 1
`

func (q *Queries) GetGitRepositoryByName(ctx context.Context, name string) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, getGitRepositoryByName, name)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.AuthType,
		&i.Username,
		&i.Token,
		&i.SshKey,
		&i.Description,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SshHostKeyVerification,
	)
	return &i, err
}

const listGitRepositories = `-- name: ListGitRepositories :many
SELECT id, name, url, auth_type, username, token, ssh_key, description, enabled, created_at, updated_at, ssh_host_key_verification
FROM git_repositories
`

func (q *Queries) ListGitRepositories(ctx context.Context) ([]*GitRepository, error) {
	rows, err := q.db.Query(ctx, listGitRepositories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GitRepository{}
	for rows.Next() {
		var i GitRepository
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Url,
			&i.AuthType,
			&i.Username,
			&i.Token,
			&i.SshKey,
			&i.Description,
			&i.Enabled,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.SshHostKeyVerification,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveGitRepository = `-- name: SaveGitRepository :one
UPDATE git_repositories
SET
    name = $1,
    url = $2,
    auth_type = $3,
    username = $4,
    token = $5,
    ssh_key = $6,
    description = $7,
    enabled = $8,
    ssh_host_key_verification = $9,
    updated_at = $10
WHERE id = $11
RETURNING id, name, url, auth_type, username, token, ssh_key, description, enabled, created_at, updated_at, ssh_host_key_verification
`

type SaveGitRepositoryParams struct {
	Name                   string             `json:"name"`
	Url                    string             `json:"url"`
	AuthType               string             `json:"auth_type"`
	Username               pgtype.Text        `json:"username"`
	Token                  pgtype.Text        `json:"token"`
	SshKey                 pgtype.Text        `json:"ssh_key"`
	Description            pgtype.Text        `json:"description"`
	Enabled                bool               `json:"enabled"`
	SshHostKeyVerification string             `json:"ssh_host_key_verification"`
	UpdatedAt              pgtype.Timestamptz `json:"updated_at"`
	ID                     string             `json:"id"`
}

func (q *Queries) SaveGitRepository(ctx context.Context, arg SaveGitRepositoryParams) (*GitRepository, error) {
	row := q.db.QueryRow(ctx, saveGitRepository,
		arg.Name,
		arg.Url,
		arg.AuthType,
		arg.Username,
		arg.Token,
		arg.SshKey,
		arg.Description,
		arg.Enabled,
		arg.SshHostKeyVerification,
		arg.UpdatedAt,
		arg.ID,
	)
	var i GitRepository
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Url,
		&i.AuthType,
		&i.Username,
		&i.Token,
		&i.SshKey,
		&i.Description,
		&i.Enabled,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.SshHostKeyVerification,
	)
	return &i, err
}
