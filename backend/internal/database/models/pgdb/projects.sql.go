// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: projects.sql

package pgdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createProject = `-- name: CreateProject :one
INSERT INTO projects (
    id,
    name,
    dir_name,
    path,
    status,
    service_count,
    running_count,
    status_reason,
    gitops_managed_by,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, name, dir_name, path, status, service_count, running_count, auto_update, is_external, is_legacy, is_remote, created_at, updated_at, status_reason, gitops_managed_by
`

type CreateProjectParams struct {
	ID              string             `json:"id"`
	Name            string             `json:"name"`
	DirName         pgtype.Text        `json:"dir_name"`
	Path            string             `json:"path"`
	Status          string             `json:"status"`
	ServiceCount    int32              `json:"service_count"`
	RunningCount    int32              `json:"running_count"`
	StatusReason    pgtype.Text        `json:"status_reason"`
	GitopsManagedBy pgtype.Text        `json:"gitops_managed_by"`
	CreatedAt       pgtype.Timestamptz `json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (*Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.ID,
		arg.Name,
		arg.DirName,
		arg.Path,
		arg.Status,
		arg.ServiceCount,
		arg.RunningCount,
		arg.StatusReason,
		arg.GitopsManagedBy,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DirName,
		&i.Path,
		&i.Status,
		&i.ServiceCount,
		&i.RunningCount,
		&i.AutoUpdate,
		&i.IsExternal,
		&i.IsLegacy,
		&i.IsRemote,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StatusReason,
		&i.GitopsManagedBy,
	)
	return &i, err
}

const deleteProjectByID = `-- name: DeleteProjectByID :execrows
DELETE FROM projects
WHERE id = $1
`

func (q *Queries) DeleteProjectByID(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteProjectByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getProjectByID = `-- name: GetProjectByID :one
SELECT id, name, dir_name, path, status, service_count, running_count, auto_update, is_external, is_legacy, is_remote, created_at, updated_at, status_reason, gitops_managed_by
FROM projects
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetProjectByID(ctx context.Context, id string) (*Project, error) {
	row := q.db.QueryRow(ctx, getProjectByID, id)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DirName,
		&i.Path,
		&i.Status,
		&i.ServiceCount,
		&i.RunningCount,
		&i.AutoUpdate,
		&i.IsExternal,
		&i.IsLegacy,
		&i.IsRemote,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StatusReason,
		&i.GitopsManagedBy,
	)
	return &i, err
}

const getProjectByPathOrDir = `-- name: GetProjectByPathOrDir :one
SELECT id, name, dir_name, path, status, service_count, running_count, auto_update, is_external, is_legacy, is_remote, created_at, updated_at, status_reason, gitops_managed_by
FROM projects
WHERE path = $1 OR dir_name = $2
LIMIT 1
`

type GetProjectByPathOrDirParams struct {
	Path    string      `json:"path"`
	DirName pgtype.Text `json:"dir_name"`
}

func (q *Queries) GetProjectByPathOrDir(ctx context.Context, arg GetProjectByPathOrDirParams) (*Project, error) {
	row := q.db.QueryRow(ctx, getProjectByPathOrDir, arg.Path, arg.DirName)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DirName,
		&i.Path,
		&i.Status,
		&i.ServiceCount,
		&i.RunningCount,
		&i.AutoUpdate,
		&i.IsExternal,
		&i.IsLegacy,
		&i.IsRemote,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StatusReason,
		&i.GitopsManagedBy,
	)
	return &i, err
}

const listProjects = `-- name: ListProjects :many
SELECT id, name, dir_name, path, status, service_count, running_count, auto_update, is_external, is_legacy, is_remote, created_at, updated_at, status_reason, gitops_managed_by
FROM projects
`

func (q *Queries) ListProjects(ctx context.Context) ([]*Project, error) {
	rows, err := q.db.Query(ctx, listProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Project{}
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DirName,
			&i.Path,
			&i.Status,
			&i.ServiceCount,
			&i.RunningCount,
			&i.AutoUpdate,
			&i.IsExternal,
			&i.IsLegacy,
			&i.IsRemote,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.StatusReason,
			&i.GitopsManagedBy,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveProject = `-- name: SaveProject :one
UPDATE projects
SET
    name = $1,
    dir_name = $2,
    path = $3,
    status = $4,
    service_count = $5,
    running_count = $6,
    status_reason = $7,
    gitops_managed_by = $8,
    updated_at = $9
WHERE id = $10
RETURNING id, name, dir_name, path, status, service_count, running_count, auto_update, is_external, is_legacy, is_remote, created_at, updated_at, status_reason, gitops_managed_by
`

type SaveProjectParams struct {
	Name            string             `json:"name"`
	DirName         pgtype.Text        `json:"dir_name"`
	Path            string             `json:"path"`
	Status          string             `json:"status"`
	ServiceCount    int32              `json:"service_count"`
	RunningCount    int32              `json:"running_count"`
	StatusReason    pgtype.Text        `json:"status_reason"`
	GitopsManagedBy pgtype.Text        `json:"gitops_managed_by"`
	UpdatedAt       pgtype.Timestamptz `json:"updated_at"`
	ID              string             `json:"id"`
}

func (q *Queries) SaveProject(ctx context.Context, arg SaveProjectParams) (*Project, error) {
	row := q.db.QueryRow(ctx, saveProject,
		arg.Name,
		arg.DirName,
		arg.Path,
		arg.Status,
		arg.ServiceCount,
		arg.RunningCount,
		arg.StatusReason,
		arg.GitopsManagedBy,
		arg.UpdatedAt,
		arg.ID,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DirName,
		&i.Path,
		&i.Status,
		&i.ServiceCount,
		&i.RunningCount,
		&i.AutoUpdate,
		&i.IsExternal,
		&i.IsLegacy,
		&i.IsRemote,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.StatusReason,
		&i.GitopsManagedBy,
	)
	return &i, err
}

const updateProjectServiceCount = `-- name: UpdateProjectServiceCount :exec
UPDATE projects
SET service_count = $1,
    updated_at = CURRENT_TIMESTAMP
WHERE id = $2
`

type UpdateProjectServiceCountParams struct {
	ServiceCount int32  `json:"service_count"`
	ID           string `json:"id"`
}

func (q *Queries) UpdateProjectServiceCount(ctx context.Context, arg UpdateProjectServiceCountParams) error {
	_, err := q.db.Exec(ctx, updateProjectServiceCount, arg.ServiceCount, arg.ID)
	return err
}

const updateProjectStatus = `-- name: UpdateProjectStatus :exec
UPDATE projects
SET status = $1,
    updated_at = $2
WHERE id = $3
`

type UpdateProjectStatusParams struct {
	Status    string             `json:"status"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
	ID        string             `json:"id"`
}

func (q *Queries) UpdateProjectStatus(ctx context.Context, arg UpdateProjectStatusParams) error {
	_, err := q.db.Exec(ctx, updateProjectStatus, arg.Status, arg.UpdatedAt, arg.ID)
	return err
}

const updateProjectStatusAndCounts = `-- name: UpdateProjectStatusAndCounts :exec
UPDATE projects
SET status = $1,
    service_count = $2,
    running_count = $3,
    updated_at = $4
WHERE id = $5
`

type UpdateProjectStatusAndCountsParams struct {
	Status       string             `json:"status"`
	ServiceCount int32              `json:"service_count"`
	RunningCount int32              `json:"running_count"`
	UpdatedAt    pgtype.Timestamptz `json:"updated_at"`
	ID           string             `json:"id"`
}

func (q *Queries) UpdateProjectStatusAndCounts(ctx context.Context, arg UpdateProjectStatusAndCountsParams) error {
	_, err := q.db.Exec(ctx, updateProjectStatusAndCounts,
		arg.Status,
		arg.ServiceCount,
		arg.RunningCount,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
