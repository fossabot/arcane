// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: compose_templates.sql

package pgdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createComposeTemplate = `-- name: CreateComposeTemplate :one
INSERT INTO compose_templates (
    id,
    name,
    description,
    content,
    env_content,
    is_custom,
    is_remote,
    registry_id,
    meta_version,
    meta_author,
    meta_tags,
    meta_remote_url,
    meta_env_url,
    meta_documentation_url,
    created_at,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)
RETURNING id, name, description, content, env_content, is_custom, is_remote, registry_id, meta_version, meta_author, meta_tags, meta_remote_url, meta_env_url, meta_documentation_url, created_at, updated_at
`

type CreateComposeTemplateParams struct {
	ID                   string             `json:"id"`
	Name                 string             `json:"name"`
	Description          pgtype.Text        `json:"description"`
	Content              pgtype.Text        `json:"content"`
	EnvContent           pgtype.Text        `json:"env_content"`
	IsCustom             bool               `json:"is_custom"`
	IsRemote             bool               `json:"is_remote"`
	RegistryID           pgtype.Text        `json:"registry_id"`
	MetaVersion          pgtype.Text        `json:"meta_version"`
	MetaAuthor           pgtype.Text        `json:"meta_author"`
	MetaTags             pgtype.Text        `json:"meta_tags"`
	MetaRemoteUrl        pgtype.Text        `json:"meta_remote_url"`
	MetaEnvUrl           pgtype.Text        `json:"meta_env_url"`
	MetaDocumentationUrl pgtype.Text        `json:"meta_documentation_url"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

type CreateComposeTemplateRow struct {
	ID                   string             `json:"id"`
	Name                 string             `json:"name"`
	Description          pgtype.Text        `json:"description"`
	Content              pgtype.Text        `json:"content"`
	EnvContent           pgtype.Text        `json:"env_content"`
	IsCustom             bool               `json:"is_custom"`
	IsRemote             bool               `json:"is_remote"`
	RegistryID           pgtype.Text        `json:"registry_id"`
	MetaVersion          pgtype.Text        `json:"meta_version"`
	MetaAuthor           pgtype.Text        `json:"meta_author"`
	MetaTags             pgtype.Text        `json:"meta_tags"`
	MetaRemoteUrl        pgtype.Text        `json:"meta_remote_url"`
	MetaEnvUrl           pgtype.Text        `json:"meta_env_url"`
	MetaDocumentationUrl pgtype.Text        `json:"meta_documentation_url"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateComposeTemplate(ctx context.Context, arg CreateComposeTemplateParams) (*CreateComposeTemplateRow, error) {
	row := q.db.QueryRow(ctx, createComposeTemplate,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.Content,
		arg.EnvContent,
		arg.IsCustom,
		arg.IsRemote,
		arg.RegistryID,
		arg.MetaVersion,
		arg.MetaAuthor,
		arg.MetaTags,
		arg.MetaRemoteUrl,
		arg.MetaEnvUrl,
		arg.MetaDocumentationUrl,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i CreateComposeTemplateRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Content,
		&i.EnvContent,
		&i.IsCustom,
		&i.IsRemote,
		&i.RegistryID,
		&i.MetaVersion,
		&i.MetaAuthor,
		&i.MetaTags,
		&i.MetaRemoteUrl,
		&i.MetaEnvUrl,
		&i.MetaDocumentationUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const deleteComposeTemplateByID = `-- name: DeleteComposeTemplateByID :execrows
DELETE FROM compose_templates
WHERE id = $1
`

func (q *Queries) DeleteComposeTemplateByID(ctx context.Context, id string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteComposeTemplateByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const findLocalComposeTemplateByDescription = `-- name: FindLocalComposeTemplateByDescription :one
SELECT id, name, description, content, env_content, is_custom, is_remote, registry_id, meta_version, meta_author, meta_tags, meta_remote_url, meta_env_url, meta_documentation_url, created_at, updated_at
FROM compose_templates
WHERE is_remote = false
  AND registry_id IS NULL
  AND description = $1
LIMIT 1
`

type FindLocalComposeTemplateByDescriptionRow struct {
	ID                   string             `json:"id"`
	Name                 string             `json:"name"`
	Description          pgtype.Text        `json:"description"`
	Content              pgtype.Text        `json:"content"`
	EnvContent           pgtype.Text        `json:"env_content"`
	IsCustom             bool               `json:"is_custom"`
	IsRemote             bool               `json:"is_remote"`
	RegistryID           pgtype.Text        `json:"registry_id"`
	MetaVersion          pgtype.Text        `json:"meta_version"`
	MetaAuthor           pgtype.Text        `json:"meta_author"`
	MetaTags             pgtype.Text        `json:"meta_tags"`
	MetaRemoteUrl        pgtype.Text        `json:"meta_remote_url"`
	MetaEnvUrl           pgtype.Text        `json:"meta_env_url"`
	MetaDocumentationUrl pgtype.Text        `json:"meta_documentation_url"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) FindLocalComposeTemplateByDescription(ctx context.Context, description pgtype.Text) (*FindLocalComposeTemplateByDescriptionRow, error) {
	row := q.db.QueryRow(ctx, findLocalComposeTemplateByDescription, description)
	var i FindLocalComposeTemplateByDescriptionRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Content,
		&i.EnvContent,
		&i.IsCustom,
		&i.IsRemote,
		&i.RegistryID,
		&i.MetaVersion,
		&i.MetaAuthor,
		&i.MetaTags,
		&i.MetaRemoteUrl,
		&i.MetaEnvUrl,
		&i.MetaDocumentationUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const findLocalComposeTemplateByDescriptionOrName = `-- name: FindLocalComposeTemplateByDescriptionOrName :one
SELECT id, name, description, content, env_content, is_custom, is_remote, registry_id, meta_version, meta_author, meta_tags, meta_remote_url, meta_env_url, meta_documentation_url, created_at, updated_at
FROM compose_templates
WHERE is_remote = false
  AND registry_id IS NULL
  AND (description = $1 OR name = $2)
LIMIT 1
`

type FindLocalComposeTemplateByDescriptionOrNameParams struct {
	Description pgtype.Text `json:"description"`
	Name        string      `json:"name"`
}

type FindLocalComposeTemplateByDescriptionOrNameRow struct {
	ID                   string             `json:"id"`
	Name                 string             `json:"name"`
	Description          pgtype.Text        `json:"description"`
	Content              pgtype.Text        `json:"content"`
	EnvContent           pgtype.Text        `json:"env_content"`
	IsCustom             bool               `json:"is_custom"`
	IsRemote             bool               `json:"is_remote"`
	RegistryID           pgtype.Text        `json:"registry_id"`
	MetaVersion          pgtype.Text        `json:"meta_version"`
	MetaAuthor           pgtype.Text        `json:"meta_author"`
	MetaTags             pgtype.Text        `json:"meta_tags"`
	MetaRemoteUrl        pgtype.Text        `json:"meta_remote_url"`
	MetaEnvUrl           pgtype.Text        `json:"meta_env_url"`
	MetaDocumentationUrl pgtype.Text        `json:"meta_documentation_url"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) FindLocalComposeTemplateByDescriptionOrName(ctx context.Context, arg FindLocalComposeTemplateByDescriptionOrNameParams) (*FindLocalComposeTemplateByDescriptionOrNameRow, error) {
	row := q.db.QueryRow(ctx, findLocalComposeTemplateByDescriptionOrName, arg.Description, arg.Name)
	var i FindLocalComposeTemplateByDescriptionOrNameRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Content,
		&i.EnvContent,
		&i.IsCustom,
		&i.IsRemote,
		&i.RegistryID,
		&i.MetaVersion,
		&i.MetaAuthor,
		&i.MetaTags,
		&i.MetaRemoteUrl,
		&i.MetaEnvUrl,
		&i.MetaDocumentationUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getComposeTemplateByID = `-- name: GetComposeTemplateByID :one
SELECT id, name, description, content, env_content, is_custom, is_remote, registry_id, meta_version, meta_author, meta_tags, meta_remote_url, meta_env_url, meta_documentation_url, created_at, updated_at
FROM compose_templates
WHERE id = $1
LIMIT 1
`

type GetComposeTemplateByIDRow struct {
	ID                   string             `json:"id"`
	Name                 string             `json:"name"`
	Description          pgtype.Text        `json:"description"`
	Content              pgtype.Text        `json:"content"`
	EnvContent           pgtype.Text        `json:"env_content"`
	IsCustom             bool               `json:"is_custom"`
	IsRemote             bool               `json:"is_remote"`
	RegistryID           pgtype.Text        `json:"registry_id"`
	MetaVersion          pgtype.Text        `json:"meta_version"`
	MetaAuthor           pgtype.Text        `json:"meta_author"`
	MetaTags             pgtype.Text        `json:"meta_tags"`
	MetaRemoteUrl        pgtype.Text        `json:"meta_remote_url"`
	MetaEnvUrl           pgtype.Text        `json:"meta_env_url"`
	MetaDocumentationUrl pgtype.Text        `json:"meta_documentation_url"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetComposeTemplateByID(ctx context.Context, id string) (*GetComposeTemplateByIDRow, error) {
	row := q.db.QueryRow(ctx, getComposeTemplateByID, id)
	var i GetComposeTemplateByIDRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Content,
		&i.EnvContent,
		&i.IsCustom,
		&i.IsRemote,
		&i.RegistryID,
		&i.MetaVersion,
		&i.MetaAuthor,
		&i.MetaTags,
		&i.MetaRemoteUrl,
		&i.MetaEnvUrl,
		&i.MetaDocumentationUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listComposeTemplates = `-- name: ListComposeTemplates :many
SELECT id, name, description, content, env_content, is_custom, is_remote, registry_id, meta_version, meta_author, meta_tags, meta_remote_url, meta_env_url, meta_documentation_url, created_at, updated_at
FROM compose_templates
`

type ListComposeTemplatesRow struct {
	ID                   string             `json:"id"`
	Name                 string             `json:"name"`
	Description          pgtype.Text        `json:"description"`
	Content              pgtype.Text        `json:"content"`
	EnvContent           pgtype.Text        `json:"env_content"`
	IsCustom             bool               `json:"is_custom"`
	IsRemote             bool               `json:"is_remote"`
	RegistryID           pgtype.Text        `json:"registry_id"`
	MetaVersion          pgtype.Text        `json:"meta_version"`
	MetaAuthor           pgtype.Text        `json:"meta_author"`
	MetaTags             pgtype.Text        `json:"meta_tags"`
	MetaRemoteUrl        pgtype.Text        `json:"meta_remote_url"`
	MetaEnvUrl           pgtype.Text        `json:"meta_env_url"`
	MetaDocumentationUrl pgtype.Text        `json:"meta_documentation_url"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListComposeTemplates(ctx context.Context) ([]*ListComposeTemplatesRow, error) {
	rows, err := q.db.Query(ctx, listComposeTemplates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListComposeTemplatesRow{}
	for rows.Next() {
		var i ListComposeTemplatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Content,
			&i.EnvContent,
			&i.IsCustom,
			&i.IsRemote,
			&i.RegistryID,
			&i.MetaVersion,
			&i.MetaAuthor,
			&i.MetaTags,
			&i.MetaRemoteUrl,
			&i.MetaEnvUrl,
			&i.MetaDocumentationUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listComposeTemplatesLite = `-- name: ListComposeTemplatesLite :many
SELECT id, name, description, ''::text AS content, NULL::text AS env_content, is_custom, is_remote, registry_id, meta_version, meta_author, meta_tags, meta_remote_url, meta_env_url, meta_documentation_url, created_at, updated_at
FROM compose_templates
`

type ListComposeTemplatesLiteRow struct {
	ID                   string             `json:"id"`
	Name                 string             `json:"name"`
	Description          pgtype.Text        `json:"description"`
	Content              string             `json:"content"`
	EnvContent           pgtype.Text        `json:"env_content"`
	IsCustom             bool               `json:"is_custom"`
	IsRemote             bool               `json:"is_remote"`
	RegistryID           pgtype.Text        `json:"registry_id"`
	MetaVersion          pgtype.Text        `json:"meta_version"`
	MetaAuthor           pgtype.Text        `json:"meta_author"`
	MetaTags             pgtype.Text        `json:"meta_tags"`
	MetaRemoteUrl        pgtype.Text        `json:"meta_remote_url"`
	MetaEnvUrl           pgtype.Text        `json:"meta_env_url"`
	MetaDocumentationUrl pgtype.Text        `json:"meta_documentation_url"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListComposeTemplatesLite(ctx context.Context) ([]*ListComposeTemplatesLiteRow, error) {
	rows, err := q.db.Query(ctx, listComposeTemplatesLite)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListComposeTemplatesLiteRow{}
	for rows.Next() {
		var i ListComposeTemplatesLiteRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Content,
			&i.EnvContent,
			&i.IsCustom,
			&i.IsRemote,
			&i.RegistryID,
			&i.MetaVersion,
			&i.MetaAuthor,
			&i.MetaTags,
			&i.MetaRemoteUrl,
			&i.MetaEnvUrl,
			&i.MetaDocumentationUrl,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveComposeTemplate = `-- name: SaveComposeTemplate :one
UPDATE compose_templates
SET
    name = $1,
    description = $2,
    content = $3,
    env_content = $4,
    is_custom = $5,
    is_remote = $6,
    registry_id = $7,
    meta_version = $8,
    meta_author = $9,
    meta_tags = $10,
    meta_remote_url = $11,
    meta_env_url = $12,
    meta_documentation_url = $13,
    updated_at = $14
WHERE id = $15
RETURNING id, name, description, content, env_content, is_custom, is_remote, registry_id, meta_version, meta_author, meta_tags, meta_remote_url, meta_env_url, meta_documentation_url, created_at, updated_at
`

type SaveComposeTemplateParams struct {
	Name                 string             `json:"name"`
	Description          pgtype.Text        `json:"description"`
	Content              pgtype.Text        `json:"content"`
	EnvContent           pgtype.Text        `json:"env_content"`
	IsCustom             bool               `json:"is_custom"`
	IsRemote             bool               `json:"is_remote"`
	RegistryID           pgtype.Text        `json:"registry_id"`
	MetaVersion          pgtype.Text        `json:"meta_version"`
	MetaAuthor           pgtype.Text        `json:"meta_author"`
	MetaTags             pgtype.Text        `json:"meta_tags"`
	MetaRemoteUrl        pgtype.Text        `json:"meta_remote_url"`
	MetaEnvUrl           pgtype.Text        `json:"meta_env_url"`
	MetaDocumentationUrl pgtype.Text        `json:"meta_documentation_url"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
	ID                   string             `json:"id"`
}

type SaveComposeTemplateRow struct {
	ID                   string             `json:"id"`
	Name                 string             `json:"name"`
	Description          pgtype.Text        `json:"description"`
	Content              pgtype.Text        `json:"content"`
	EnvContent           pgtype.Text        `json:"env_content"`
	IsCustom             bool               `json:"is_custom"`
	IsRemote             bool               `json:"is_remote"`
	RegistryID           pgtype.Text        `json:"registry_id"`
	MetaVersion          pgtype.Text        `json:"meta_version"`
	MetaAuthor           pgtype.Text        `json:"meta_author"`
	MetaTags             pgtype.Text        `json:"meta_tags"`
	MetaRemoteUrl        pgtype.Text        `json:"meta_remote_url"`
	MetaEnvUrl           pgtype.Text        `json:"meta_env_url"`
	MetaDocumentationUrl pgtype.Text        `json:"meta_documentation_url"`
	CreatedAt            pgtype.Timestamptz `json:"created_at"`
	UpdatedAt            pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) SaveComposeTemplate(ctx context.Context, arg SaveComposeTemplateParams) (*SaveComposeTemplateRow, error) {
	row := q.db.QueryRow(ctx, saveComposeTemplate,
		arg.Name,
		arg.Description,
		arg.Content,
		arg.EnvContent,
		arg.IsCustom,
		arg.IsRemote,
		arg.RegistryID,
		arg.MetaVersion,
		arg.MetaAuthor,
		arg.MetaTags,
		arg.MetaRemoteUrl,
		arg.MetaEnvUrl,
		arg.MetaDocumentationUrl,
		arg.UpdatedAt,
		arg.ID,
	)
	var i SaveComposeTemplateRow
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Content,
		&i.EnvContent,
		&i.IsCustom,
		&i.IsRemote,
		&i.RegistryID,
		&i.MetaVersion,
		&i.MetaAuthor,
		&i.MetaTags,
		&i.MetaRemoteUrl,
		&i.MetaEnvUrl,
		&i.MetaDocumentationUrl,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}
